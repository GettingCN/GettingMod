package cn.cngetting.gettingmod.feature.tree;

import cn.cngetting.gettingmod.feature.ModFeature;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.block.BlockState;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3i;
import net.minecraft.util.math.intprovider.IntProvider;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.TestableWorld;
import net.minecraft.world.gen.feature.TreeFeatureConfig;
import net.minecraft.world.gen.foliage.FoliagePlacer;
import net.minecraft.world.gen.foliage.FoliagePlacerType;

import java.util.function.BiConsumer;

public class RichFoliagePlacer extends FoliagePlacer {
    // For the foliageHeight we use a codec generated by IntProvider.createValidatingCodec
    // As the method's arguments, we pass in the minimum and maximum value of the IntProvider
    // To add more fields into your TrunkPlacer/FoliagePlacer/TreeDecorator etc., use multiple .and calls
    // For an example of creating your own type of codec, see the IntProvider.createValidatingCodec method's source
    // 对于叶子高度，我们使用由 IntProvider.createValidatingCodec 生成的编解码器
    // 作为方法的参数，我们传入 IntProvider 的最小值和最大值
    // 要将更多字段添加到您的 TrunkPlacerFoliagePlacerTreeDecorator 等中，请使用多个 .and 调用
    // 有关创建自己的编解码器类型的示例，请参阅 IntProvider.createValidatingCodec 方法的源代码
    public static final Codec<RichFoliagePlacer> CODEC = RecordCodecBuilder.create(instance ->
            fillFoliagePlacerFields(instance)
                    .and(
                            IntProvider.createValidatingCodec(1, 512)
                                    .fieldOf("foliage_height")
                                            .forGetter(
                                            RichFoliagePlacer::getFoliageHeight))
                    .apply(instance, RichFoliagePlacer::new));

    private final IntProvider foliageHeight;

    public RichFoliagePlacer(IntProvider radius, IntProvider offset, IntProvider foliageHeight) {
        super(radius, offset);

        this.foliageHeight = foliageHeight;
    }

    public IntProvider getFoliageHeight() {
        return this.foliageHeight;
    }

    @Override
    protected FoliagePlacerType<?> getType() {
        return ModFeature.RICH_FOLIAGE_PLACER;
    }

    @Override
    protected void generate(TestableWorld world, BiConsumer<BlockPos, BlockState> replacer, Random random, TreeFeatureConfig config, int trunkHeight, TreeNode treeNode, int foliageHeight, int radius, int offset) {
        //int rad = this.getRandomRadius(random, radius);
        for (int y = offset; y >= offset - foliageHeight; --y) {
            int _radius = /*rad*/radius + treeNode.getFoliageRadius() - 1 - y;
            //this.generateSquare(world, replacer, random, config, treeNode.getCenter(), _radius, _offset, treeNode.isGiantTrunk());
            int trunk = treeNode.isGiantTrunk() ? 1 : 0;
            BlockPos.Mutable mutable = new BlockPos.Mutable();
            for (int x = -_radius; x <= _radius + trunk; ++x) {
                for (int z = -_radius; z <= _radius + trunk; ++z) {
                    if (this.isPositionInvalid(random, x, y, z, _radius, treeNode.isGiantTrunk())) continue;
                    mutable.set(treeNode.getCenter(), x, y, z);
                    placeFoliageBlock(world, replacer, random, config, mutable);
                }
            }
        }
        // wiki提供错误事例
        /*BlockPos.Mutable center = treeNode.getCenter().mutableCopy();
        for (
            // 从 X 开始：中心-半径
                Vec3i vec = center.subtract(new Vec3i(radius, 0, 0));
            // 以 X 结尾：中心 + 半径
                vec.compareTo(center.add(new Vec3i(radius, 0, 0))) == 0;
            // 每次移动 1 次
                vec.add(1, 0, 0)) {
            FoliagePlacer.placeFoliageBlock(world, replacer, random, config, new BlockPos(vec));
        }

        for (
                Vec3i vec = center.subtract(new Vec3i(0, radius, 0));
                vec.compareTo(center.add(new Vec3i(0, radius, 0))) == 0;
                vec.add(0, 1, 0)) {
            FoliagePlacer.placeFoliageBlock(world, replacer, random, config, new BlockPos(vec));
        }*/
    }

    @Override
    public int getRandomHeight(Random random, int trunkHeight, TreeFeatureConfig config) {
        // Just pick the random height using the IntProvider
        return foliageHeight.get(random);
    }

    @Override
    protected boolean isInvalidForLeaves(Random random, int dx, int y, int dz, int radius, boolean giantTrunk) {
        // Our FoliagePlacer doesn't set any restrictions on leaves
        // 我们的叶子放置器不对叶子设置任何限制
        return false;
    }
}